// Code generated by protoc-gen-grpchan. DO NOT EDIT.
// source: plugin.proto

package pluginrpc

import (
	"github.com/librato/grpchan"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

func RegisterHandlerController(reg grpchan.ServiceRegistry, srv ControllerServer) {
	reg.RegisterService(&_Controller_serviceDesc, srv)
}

type controllerChannelClient struct {
	ch grpchan.Channel
}

func NewControllerChannelClient(ch grpchan.Channel) ControllerClient {
	return &controllerChannelClient{ch: ch}
}

func (c *controllerChannelClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Controller/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerChannelClient) Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*KillResponse, error) {
	out := new(KillResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Controller/Kill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func RegisterHandlerCollector(reg grpchan.ServiceRegistry, srv CollectorServer) {
	reg.RegisterService(&_Collector_serviceDesc, srv)
}

type collectorChannelClient struct {
	ch grpchan.Channel
}

func NewCollectorChannelClient(ch grpchan.Channel) CollectorClient {
	return &collectorChannelClient{ch: ch}
}

func (c *collectorChannelClient) Collect(ctx context.Context, in *CollectRequest, opts ...grpc.CallOption) (Collector_CollectClient, error) {
	stream, err := c.ch.NewStream(ctx, &_Collector_serviceDesc.Streams[0], "/pluginrpc.Collector/Collect", opts...)
	if err != nil {
		return nil, err
	}
	x := &collectorCollectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

func (c *collectorChannelClient) Load(ctx context.Context, in *LoadCollectorRequest, opts ...grpc.CallOption) (*LoadCollectorResponse, error) {
	out := new(LoadCollectorResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Collector/Load", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorChannelClient) Unload(ctx context.Context, in *UnloadCollectorRequest, opts ...grpc.CallOption) (*UnloadCollectorResponse, error) {
	out := new(UnloadCollectorResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Collector/Unload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorChannelClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Collector/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func RegisterHandlerPublisher(reg grpchan.ServiceRegistry, srv PublisherServer) {
	reg.RegisterService(&_Publisher_serviceDesc, srv)
}

type publisherChannelClient struct {
	ch grpchan.Channel
}

func NewPublisherChannelClient(ch grpchan.Channel) PublisherClient {
	return &publisherChannelClient{ch: ch}
}

func (c *publisherChannelClient) Publish(ctx context.Context, opts ...grpc.CallOption) (Publisher_PublishClient, error) {
	stream, err := c.ch.NewStream(ctx, &_Publisher_serviceDesc.Streams[0], "/pluginrpc.Publisher/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &publisherPublishClient{stream}
	return x, nil
}

func (c *publisherChannelClient) Load(ctx context.Context, in *LoadPublisherRequest, opts ...grpc.CallOption) (*LoadPublisherResponse, error) {
	out := new(LoadPublisherResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Publisher/Load", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherChannelClient) Unload(ctx context.Context, in *UnloadPublisherRequest, opts ...grpc.CallOption) (*UnloadPublisherResponse, error) {
	out := new(UnloadPublisherResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Publisher/Unload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherChannelClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.ch.Invoke(ctx, "/pluginrpc.Publisher/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}
